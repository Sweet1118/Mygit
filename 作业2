一、“==”与“equals”的区别
1.对于基本类型的变量：
  ==用来比较两个变量的值是否相同
  equals不能用来比较基本数据类型
2.对于对象类型变量：
  ==用来比较两个变量的内存地址是否相同
  equals用来比较对象是否相同
例如String st1="Mike ";String st2="is man";String st3="Make is man";String st4="Mike is man";
    Boolean p1=(st1+st2)==st3;
    Boolean p2=(st3==st4);
    Boolean p3=(st1+st2).equals(st3);
    Boolean p4=st3.equals(st4);
结果为：p1=false p2=true p3=true p4=true


二、浅拷贝、深拷贝的比较
1、C#
浅拷贝(影子克隆):只复制对象的基本类型,对象类型,仍属于原来的引用. 
深拷贝(深度克隆):不紧复制对象的基本类,同时也复制原对象中的对象.就是说完全是新对象产生的.
深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。
    举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。比较典型的就是Value（值）对象，如预定义类型Int32，Double，以及结构（struct），枚举（Enum）等。
浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同），对其中任何一个对象的改动都会影响另外一个对象。
    举个例子，一个人一开始叫张三，后来改名叫李四了，可是还是同一个人，不管是张三缺胳膊少腿还是李四缺胳膊少腿，都是这个人倒霉。
C#中有两种类型变量，一种是值类型变量，一种是引用类型变量。对于前者，copy是属于全盘复制；而对于后者，一般的copy只是浅copy，相当于只传递一个引用指针一样。
因此 对于后者进行真正copy的时候，也是最费事的，具体的说，必须为其实现ICloneable接口中提供的Clone方法。

浅拷贝和深拷贝的区别：
浅拷贝是指将对象中的数值类型的字段拷贝到新的对象中，而对象中的引用型字段则指复制它的一个引用到目标对象。如果改变目标对象 中引用型字段的值他将反映在原是对象中，也就是说原始对象中对应的字段也会发生变化。
深拷贝与浅拷贝不同的是对于引用的处理，深拷贝将会在新对象中创建一 个新的和原是对象中对应字段相同（内容相同）的字段，也就是说这个引用和原是对象的引用是不同的，我们在改变新对象中的这个字段的时候是不会影响到原始对 象中对应字段的内容。
所以对于原型模式也有不同的两种处理方法：对象的浅拷贝和深拷贝。

2．Java的clone()方法 
⑴clone方法将对象复制了一份并返回给调用者。一般而言，clone（）方法满足： 
①对任何的对象x，都有x.clone() !=x//克隆对象与原对象不是同一个对象 
②对任何的对象x，都有x.clone().getClass()= =x.getClass()//克隆对象与原对象的类型一样 
③如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。 

⑵Java中对象的克隆 
①为了获取对象的一份拷贝，我们可以利用Object类的clone()方法。 
②在派生类中覆盖基类的clone()方法，并声明为public。 
③在派生类的clone()方法中，调用super.clone()。 
④在派生类中实现Cloneable接口。 

3．利用串行化来做深拷贝（主要是为了避免重写比较复杂对象的深拷贝的clone（）方法，也可以程序实现断点续传等等功能） 
    把对象写到流里的过程是串行化（Serilization）过程，但是在Java程序师圈子里又非常形象地称为“冷冻”或者“腌咸菜（picking）”过程；而把对象从流中读出来的并行化（Deserialization）过程则叫做 “解冻”或者“回鲜(depicking)”过程。 
    应当指出的是，写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面，因此“腌成咸菜”的只是对象的一个拷贝，Java咸菜还可以回鲜。 
    在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里（腌成咸菜），再从流里读出来（把咸菜回鲜），便可以重建对象。 

三、单例模式的使用
单例模式是所有设计模式中最简单的一种。
单例模式就是说系统中对于某类的只能有一个对象，不可能出来第二个。（就是这个类只能被实例化一次, 以后取出来的都是它的实例）
有很多时候必须要创建一个对象，并且不能创建多个，用单例就为了防止创建多个对象。比方说一个学校只有一个校长，不能有两个，有两个也出问题了，像校长这个类就必须做成单例的。单例模式是一种设计模式，只能创建一个对象。也不能说有什么好处和坏处。主要考察的是多线程下面单例模式的线程安全性问题。
